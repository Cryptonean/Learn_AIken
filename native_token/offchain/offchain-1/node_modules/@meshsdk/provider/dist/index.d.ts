import { IFetcher, IListener, ISubmitter, IEvaluator, AccountInfo, UTxO, AssetMetadata, BlockInfo, Asset, Protocol, TransactionInfo, Action, Network } from '@meshsdk/common';

/**
 * The BeginProvider class provides methods to query Begin ID.
 *
 * To use this provider, simply create a new instance of the BeginProvider class and call the desired method.
 *
 * ```typescript
 * import { BeginProvider } from "@meshsdk/core";
 *
 * const beginProvider = new BeginProvider();
 * ```
 */
declare class BeginProvider {
    private readonly apikey;
    private readonly chainNumber;
    private readonly domainUrl;
    /**
     * Creates a new instance of the BeginProvider.
     * @param apikey The API key for querying Begin ID.
     */
    constructor(apikey?: string);
    /**
     * Given a Begin ID, resolves the address and other information.
     * @param name name of Begin ID, e.g. `mesh`
     * @param url optional URL to override the default: https://resolveidaddress-ylo5dtxzdq-uc.a.run.app
     * @returns
     * - name: string
     * - domain: string
     * - image: string
     * - address: string
     */
    resolveAddress(name: string, url?: string): Promise<{
        name: string;
        domain: string;
        image: string;
        address: string;
    }>;
    /**
     * Given an address, resolves the Begin ID and other information.
     * @param address address to resolve
     * @param url optional URL to override the default: https://resolveIdReserveAddress-ylo5dtxzdq-uc.a.run.app
     * @returns
     * - name: string
     * - domain: string
     * - image: string
     * - address: string
     */
    resolveAdressReverse(address: string, url?: string): Promise<{
        name: string;
        domain: string;
        image: string;
        address: string;
    }>;
}

type BlockfrostSupportedNetworks = "mainnet" | "preview" | "preprod";
/**
 * Blockfrost provides restful APIs which allows your app to access information stored on the blockchain.
 *
 * Usage:
 * ```
 * import { BlockfrostProvider } from "@meshsdk/core";
 *
 * const blockchainProvider = new BlockfrostProvider('<Your-API-Key>');
 */
declare class BlockfrostProvider implements IFetcher, IListener, ISubmitter, IEvaluator {
    private readonly _axiosInstance;
    private readonly _network;
    /**
     * If you are using a privately hosted Blockfrost instance, you can set the URL in the parameter.
     * @param baseUrl The base URL of the instance.
     */
    constructor(baseUrl: string);
    /**
     * If you are using [Blockfrost](https://blockfrost.io/) hosted instance, you can set the project ID in the parameter.
     * @param projectId The project ID of the instance.
     * @param version The version of the API. Default is 0.
     */
    constructor(projectId: string, version?: number);
    /**
     * Evaluates the resources required to execute the transaction
     * @param tx - The transaction to evaluate
     */
    evaluateTx(cbor: string): Promise<any>;
    /**
     * Obtain information about a specific stake account.
     * @param address - Wallet address to fetch account information
     */
    fetchAccountInfo(address: string): Promise<AccountInfo>;
    /**
     * Fetches the assets for a given address.
     * @param address - The address to fetch assets for
     * @returns A map of asset unit to quantity
     */
    fetchAddressAssets(address: string): Promise<{
        [key: string]: string;
    }>;
    fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]>;
    /**
     * Fetches the asset addresses for a given asset.
     * @param asset - The asset to fetch addresses for
     */
    fetchAssetAddresses(asset: string): Promise<{
        address: string;
        quantity: string;
    }[]>;
    /**
     * Fetches the metadata for a given asset.
     * @param asset - The asset to fetch metadata for
     * @returns The metadata for the asset
     */
    fetchAssetMetadata(asset: string): Promise<AssetMetadata>;
    /**
     * Fetches the metadata for a given asset.
     * @param asset - The asset to fetch metadata for
     * @returns The metadata for the asset
     */
    fetchLatestBlock(): Promise<BlockInfo>;
    fetchBlockInfo(hash: string): Promise<BlockInfo>;
    fetchCollectionAssets(policyId: string, cursor?: number): Promise<{
        assets: Asset[];
        next: string | number | null;
    }>;
    fetchHandle(handle: string): Promise<AssetMetadata>;
    fetchHandleAddress(handle: string): Promise<string>;
    fetchProtocolParameters(epoch?: number): Promise<Protocol>;
    fetchTxInfo(hash: string): Promise<TransactionInfo>;
    fetchUTxOs(hash: string): Promise<UTxO[]>;
    get(url: string): Promise<any>;
    /**
     * Allow you to listen to a transaction confirmation. Upon confirmation, the callback will be called.
     * @param txHash - The transaction hash to listen for confirmation
     * @param callback - The callback function to call when the transaction is confirmed
     * @param limit - The number of blocks to wait for confirmation
     */
    onTxConfirmed(txHash: string, callback: () => void, limit?: number): void;
    /**
     * Submit a serialized transaction to the network.
     * @param tx - The serialized transaction in hex to submit
     * @returns The transaction hash of the submitted transaction
     */
    submitTx(tx: string): Promise<string>;
    private resolveScriptRef;
    private toUTxO;
    private fetchPlutusScriptCBOR;
    private fetchNativeScriptJSON;
}

/**
 * Experimental Hydra provider - WIP and breaking changes are expected
 */
declare class HydraProvider {
    private readonly _baseUrl;
    private readonly _eventEmitter;
    private _client;
    private readonly _axiosInstance;
    constructor(url: string);
    /**
     * Submit a transaction to the Hydra node. Note, unlike other providers, Hydra does not return a transaction hash.
     * @param tx - The transaction in CBOR hex format
     */
    submitTx(tx: string): Promise<void>;
    connect(): Promise<void>;
    check(): void;
    /**
     * Initializes a new Head. This command is a no-op when a Head is already open and the server will output an CommandFailed message should this happen.
     */
    initializesHead(): Promise<void>;
    fetchUtxoSnapshot(): Promise<UTxO[]>;
    fetchAddressUTxOs(address: string): Promise<UTxO[]>;
    fetchProtocolParameters(): Promise<Protocol>;
    receiveMessage(message: MessageEvent): Promise<void>;
    onMessage(callback: (message: unknown) => void): void;
    private sendCommand;
    private toUTxO;
    private toAssets;
}

type KoiosSupportedNetworks = "api" | "preview" | "preprod" | "guild";
declare class KoiosProvider implements IFetcher, IListener, ISubmitter {
    private readonly _axiosInstance;
    private readonly _network;
    constructor(baseUrl: string);
    constructor(network: KoiosSupportedNetworks, token: string, version?: number);
    fetchAccountInfo(address: string): Promise<AccountInfo>;
    fetchAddressAssets(address: string): Promise<{
        [key: string]: string;
    }>;
    fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]>;
    fetchAssetAddresses(asset: string): Promise<{
        address: string;
        quantity: string;
    }[]>;
    fetchAssetMetadata(asset: string): Promise<AssetMetadata>;
    fetchBlockInfo(hash: string): Promise<BlockInfo>;
    fetchCollectionAssets(policyId: string): Promise<{
        assets: Asset[];
    }>;
    fetchHandle(handle: string): Promise<AssetMetadata>;
    fetchHandleAddress(handle: string): Promise<string>;
    fetchProtocolParameters(epoch?: number): Promise<Protocol>;
    fetchTxInfo(hash: string): Promise<TransactionInfo>;
    fetchUTxOs(hash: string): Promise<UTxO[]>;
    get(url: string): Promise<any>;
    onTxConfirmed(txHash: string, callback: () => void, limit?: number): void;
    submitTx(tx: string): Promise<string>;
    private toUTxO;
    private resolveScriptRef;
}

type MaestroSupportedNetworks = "Mainnet" | "Preprod" | "Preview";
interface MaestroConfig {
    network: MaestroSupportedNetworks;
    apiKey: string;
    turboSubmit?: boolean;
}
declare class MaestroProvider implements IFetcher, ISubmitter, IEvaluator, IListener {
    private readonly _axiosInstance;
    private readonly _amountsAsStrings;
    private readonly _network;
    submitUrl: string;
    constructor({ network, apiKey, turboSubmit }: MaestroConfig);
    evaluateTx(cbor: string): Promise<Omit<Action, "data">[]>;
    fetchAccountInfo(address: string): Promise<AccountInfo>;
    fetchAddressAssets(address: string): Promise<{
        [key: string]: string;
    }>;
    fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]>;
    fetchAssetAddresses(asset: string): Promise<{
        address: string;
        quantity: string;
    }[]>;
    fetchAssetMetadata(asset: string): Promise<AssetMetadata>;
    fetchBlockInfo(hash: string): Promise<BlockInfo>;
    fetchCollectionAssets(policyId: string, cursor?: string): Promise<{
        assets: Asset[];
        next: string | number | null;
    }>;
    fetchHandle(handle: string): Promise<object>;
    fetchHandleAddress(handle: string): Promise<string>;
    fetchProtocolParameters(epoch?: number): Promise<Protocol>;
    fetchTxInfo(hash: string): Promise<TransactionInfo>;
    fetchUTxOs(hash: string): Promise<UTxO[]>;
    get(url: string): Promise<any>;
    onTxConfirmed(txHash: string, callback: () => void, limit?: number): void;
    submitTx(tx: string): Promise<string>;
    private toUTxO;
    private resolveScript;
}

declare class OgmiosProvider implements IEvaluator, ISubmitter {
    private readonly _baseUrl;
    constructor(baseUrl: string);
    constructor(network: Network);
    evaluateTx(tx: string): Promise<Omit<Action, "data">[]>;
    onNextTx(callback: (tx: unknown) => void): Promise<() => void>;
    submitTx(tx: string): Promise<string>;
    private open;
    private send;
}

/**
 * A UTxO RPC Provider for [MeshJS](https://meshjs.dev/) Transaction Builder Library.
 *
 * Example usage of how to use the UTxO RPC provider with Mesh to build and submit a transaction.
 * ```
 * // Step #1
 * // Import Mesh SDK and UTxO RPC provider
 * import { Transaction, MeshWallet, U5CProvider } from "@meshsdk/core";
 *
 * async function main() {
 *   // Step #2
 *   // Create a new U5C provider
 *   const provider = new U5CProvider({
 *     url: "http://localhost:50051",
 *     headers: {
 *       "dmtr-api-key": "<api-key>",
 *     },
 *   });
 *
 *   // Step #3
 *   // Create a new wallet from a mnemonic
 *   const wallet = new MeshWallet({
 *     networkId: 0, // 0: testnet, 1: mainnet
 *     fetcher: provider,
 *     submitter: provider,
 *     key: {
 *       type: "mnemonic",
 *       words: [
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *       ],
 *     },
 *   });
 *
 *   // Optional: Print the wallet address
 *   console.log(wallet.getChangeAddress());
 *
 *   // Optional: Print the wallet utxos
 *   console.log(await provider.fetchAddressUTxOs(wallet.getChangeAddress()));
 *
 *   // Step #4
 *   // Create an example transaction that sends 5 ADA to an address
 *   const tx = new Transaction({
 *     initiator: wallet,
 *     verbose: false,
 *   }).sendLovelace(
 *     "addr_test1vpvx0sacufuypa2k4sngk7q40zc5c4npl337uusdh64kv0c7e4cxr",
 *     "5000000"
 *   );
 *   const unsignedTx = await tx.build();
 *
 *   // Step #5
 *   // Sign the transaction
 *   const signedTx = wallet.signTx(unsignedTx);
 *
 *   // Step #6
 *   // Submit the transaction to the blockchain network
 *   const txId = await provider.submitTx(signedTx);
 *
 *   // Optional: Print the transaction ID
 *   console.log("Transaction ID", txId);
 * }
 *
 * main().catch(console.error);
 * ```
 */
declare class U5CProvider implements IFetcher, ISubmitter, IEvaluator, IListener {
    private queryClient;
    private submitClient;
    /**
     * Constructor initializes the query and submit clients with provided URL and optional headers.
     * @param url - The base URL for interacting with Cardano nodes.
     * @param headers - Optional HTTP headers for API requests.
     */
    constructor({ url, headers, }: {
        url: string;
        headers?: Record<string, string>;
    });
    /**
     * Allow you to listen to a transaction confirmation. Upon confirmation, the callback will be called.
     * @param txHash - The transaction hash to listen for confirmation
     * @param callback - The callback function to call when the transaction is confirmed
     * @param limit - The number of blocks to wait for confirmation
     */
    onTxConfirmed(txHash: string, callback: () => void, limit?: number): void;
    /**
     * Evaluates the resources required to execute the transaction
     * @param tx - The transaction to evaluate
     */
    evaluateTx(tx: string): Promise<Omit<Action, "data">[]>;
    /**
     * Submit a serialized transaction to the network.
     * @param tx - The serialized transaction in hex to submit
     * @returns The transaction hash of the submitted transaction
     */
    submitTx(tx: string): Promise<string>;
    /**
     * Obtain information about a specific stake account.
     * @param address - Wallet address to fetch account information
     */
    fetchAccountInfo(address: string): Promise<AccountInfo>;
    fetchAddressAssets(address: string): Promise<{
        [key: string]: string;
    }>;
    /**
     * Fetches the UTxOs for a given address.
     * @param address - The address to fetch UTxOs for
     * @param asset - The asset to filter UTxOs by (optional)
     * @returns UTxOs for the given address
     */
    fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]>;
    /**
     * Fetches the asset addresses for a given asset.
     * @param asset - The asset to fetch addresses for
     */
    fetchAssetAddresses(asset: string): Promise<{
        address: string;
        quantity: string;
    }[]>;
    /**
     * Fetches the metadata for a given asset.
     * @param asset - The asset to fetch metadata for
     */
    fetchAssetMetadata(asset: string): Promise<AssetMetadata>;
    /**
     * Fetches the block information for a given block hash.
     * @param hash - The block hash to fetch block information for
     */
    fetchBlockInfo(hash: string): Promise<BlockInfo>;
    /**
     * Fetches the collection assets for a given policy ID.
     * @param policyId - The policy ID to fetch collection assets for
     * @param cursor - The cursor to fetch the next set of assets (optional)
     */
    fetchCollectionAssets(policyId: string, cursor?: number | string): Promise<{
        assets: Asset[];
        next?: string | number | null;
    }>;
    /**
     * Fetches the information (AssetMetadata) for a given handle.
     * @param handle - The handle to fetch information for
     */
    fetchHandle(handle: string): Promise<object>;
    /**
     * Resolve the handle's address from the handle.
     * @param handle - The handle to resolve
     */
    fetchHandleAddress(handle: string): Promise<string>;
    /**
     * Fetches protocol parameters
     */
    fetchProtocolParameters(epoch?: number): Promise<Protocol>;
    /**
     * Fetches transaction info for a given hash.
     * @param hash - The transaction hash
     */
    fetchTxInfo(hash: string): Promise<TransactionInfo>;
    /**
     * Fetches output UTxOs of a given transaction hash.
     * @param hash - The transaction hash
     */
    fetchUTxOs(hash: string): Promise<UTxO[]>;
    get(url: string): Promise<any>;
    /**
     * Waits for transaction confirmation within a given timeout.
     * @param txId - The transaction hash.
     * @param timeout - Optional timeout in milliseconds.
     * @returns True if the transaction is confirmed within the timeout, otherwise false.
     */
    awaitTransactionConfirmation(txId: string, timeout?: number): Promise<boolean>;
    /**
     * Helper function to convert an RPC UTxO object to a Mesh UTxO object.
     * @param rpcTxoRef - The transaction output reference from RPC.
     * @param rpcTxOutput - The transaction output details from RPC.
     * @returns A formatted UTxO object.
     */
    private _rpcUtxoToMeshUtxo;
    /**
     * Converts RPC protocol parameters to a Mesh Protocol object.
     * @param rpcPParams - The protocol parameters from the RPC.
     * @returns A Protocol object.
     */
    private _rpcPParamsToProtocol;
}

/**
 * Yaci DevKit is a development tool designed for rapid and efficient Cardano blockchain development. It allows developers to create and destroy custom Cardano devnets in seconds, providing fast feedback loops and simplifying the iteration process.
 *
 * Get started:
 * ```typescript
 * import { YaciProvider } from "@meshsdk/core";
 * const blockchainProvider = new YaciProvider('<YACI_URL>', '<OPTIONAL_ADMIN_URL>');
 * ```
 */
declare class YaciProvider implements IFetcher, IListener, ISubmitter, IEvaluator {
    private readonly _axiosInstance;
    private readonly _adminAxiosInstance;
    /**
     * Set the URL of the instance.
     * @param baseUrl The base URL of the instance.
     */
    constructor(baseUrl?: string, adminUrl?: string);
    fetchAccountInfo(address: string): Promise<AccountInfo>;
    private resolveScriptRef;
    private toUTxO;
    fetchAddressAssets(address: string): Promise<{
        [key: string]: string;
    }>;
    fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]>;
    fetchAssetAddresses(asset: string): Promise<{
        address: string;
        quantity: string;
    }[]>;
    fetchAssetMetadata(asset: string): Promise<AssetMetadata>;
    fetchBlockInfo(hash: string): Promise<BlockInfo>;
    fetchCollectionAssets(policyId: string, cursor?: number): Promise<{
        assets: Asset[];
        next: string | number | null;
    }>;
    fetchHandle(handle: string): Promise<object>;
    fetchHandleAddress(handle: string): Promise<string>;
    fetchProtocolParameters(epoch?: number): Promise<Protocol>;
    fetchTxInfo(hash: string): Promise<TransactionInfo>;
    fetchUTxOs(hash: string): Promise<UTxO[]>;
    get(url: string): Promise<any>;
    onTxConfirmed(txHash: string, callback: () => void, limit?: number): void;
    submitTx(txHex: string): Promise<string>;
    evaluateTx(txHex: string): Promise<Omit<Action, "data">[]>;
    getDevnetInfo(): Promise<void>;
    getGenesisByEra(era: string): Promise<void>;
    /**
     * Topup address with ADA
     * @param address - Address to topup
     * @param amount - Amount to topup
     */
    addressTopup(address: string, amount: string): Promise<void>;
    private fetchPlutusScriptCBOR;
    private fetchNativeScriptJSON;
}

type AssetAddress = {
    address: string;
    quantity: string;
};
declare class OfflineFetcher implements IFetcher {
    private accounts;
    private utxos;
    private assetAddresses;
    private assetMetadata;
    private blocks;
    private collections;
    private protocolParameters;
    private transactions;
    private paginate;
    fetchAccountInfo(address: string): Promise<AccountInfo>;
    fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]>;
    fetchAssetAddresses(asset: string): Promise<AssetAddress[]>;
    fetchAssetMetadata(asset: string): Promise<AssetMetadata>;
    fetchBlockInfo(hash: string): Promise<BlockInfo>;
    fetchCollectionAssets(policyId: string, cursor?: number | string): Promise<{
        assets: Asset[];
        next?: string | number;
    }>;
    fetchHandle(handle: string): Promise<AssetMetadata>;
    fetchHandleAddress(handle: string): Promise<string>;
    fetchProtocolParameters(epoch: number): Promise<Protocol>;
    fetchTxInfo(hash: string): Promise<TransactionInfo>;
    fetchUTxOs(hash: string): Promise<UTxO[]>;
    get(url: string): Promise<any>;
    toJSON(): string;
    static fromJSON(json: string): OfflineFetcher;
    private static isValidHex;
    private static isValidAddress;
    private static isValidBase58;
    private static isValidBech32;
    private static isValidBech32Address;
    private static isValidBech32Pool;
    private static isValidBech32VrfVk;
    private static isIntegerString;
    private static isValidAssetOrLovelace;
    addAccount(address: string, accountInfo: AccountInfo): void;
    addUTxOs(utxos: UTxO[]): void;
    addAssetAddresses(asset: string, addresses: AssetAddress[]): void;
    addAssetMetadata(asset: string, metadata: AssetMetadata): void;
    addCollectionAssets(assets: Asset[]): void;
    addProtocolParameters(parameters: Protocol): void;
    addTransaction(txInfo: TransactionInfo): void;
    addBlock(blockInfo: BlockInfo): void;
}

export { BeginProvider, BlockfrostProvider, type BlockfrostSupportedNetworks, HydraProvider, KoiosProvider, type KoiosSupportedNetworks, MaestroProvider, type MaestroSupportedNetworks, OfflineFetcher, OgmiosProvider, U5CProvider, YaciProvider };
